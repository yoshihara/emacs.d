#+TITLE: emacsの設定
#+STARTUP: overview

# MEMO: コードブロックの挿入は C-c C-, s してから emacs-lisp を追加
# MEMO: コードブロックを別バッファで編集するときは C-c ' （終了もこれ）

# .emacs.d/init.el を見て上から順番にいるものを書いていく、セクションは逐一追加
# 1個移動したら起動確認からのコミット
# 旧版を移行しながらやりたいこと、終わってから変えたいことはそれぞれ以下のセクションに書いておく

* 旧版移行ログ

~/.emacs/config/*.el に対応している。

- [X] global
- [X] face
- [X] keybinds
- [X] commands
- [X] builtin-packages
- [ ] package-managers
- [ ] modes
- [ ] other-packages
- [ ] cocoa-emacs-miscs
- [ ] linux-miscs（会社じゃないと駄目かも）

* 旧版を移行しながらやりたいこと

- [ ] leaf の導入 https://www.grugrut.net/posts/my-emacs-init-el/ のパッケージ導入
- [ ] helm 以外のUI https://blog.tomoya.dev/posts/a-new-wave-has-arrived-at-emacs/

* 旧版を移行し終わったらやりたいこと

- [ ] https://emacs-jp.github.io/tips/emacs-in-2020 を参考にして使いそうなのを入れる
- [ ] skk の辞書
- [ ] skk でENTERで変換確定するようにする
- [ ] ↓セクションの整理（今は仮）

* emacs の挙動設定

** debug

#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

** 音

エラー音を鳴らさないようにする。

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** ファイル

*** ファイルの種類による挙動変化

圧縮ファイルは解凍したものを開くようにする。

#+begin_src emacs-lisp
  (auto-compression-mode t)
#+end_src

画像ファイルを直接開く。

#+begin_src emacs-lisp
  (auto-image-file-mode t)
#+end_src

ファイル先頭にshebangが付いているファイルは自動で実行権限を付ける。

#+begin_src emacs-lisp
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+end_src

*** バックアップ

#+begin_src emacs-lisp
  (setq make-backup-files t)
  (setq backup-inhibited t)
  (setq delete-auto-save-files t)
#+end_src

** 言語環境と文字コード

#+begin_src emacs-lisp
  (set-locale-environment nil)
  (set-language-environment 'Japanese)
  (prefer-coding-system 'utf-8)
#+end_src

** 履歴

#+begin_src emacs-lisp
  (setq history-length 10000)
  (savehist-mode 1)
  (setq recentf-max-saved-items 10000)
#+end_src

** クリップボード

*** kill/yankでクリップボードにアクセスする

#+begin_src emacs-lisp
  (cond (window-system
         (setq x-select-enable-clipboard t)
  ))
#+end_src

** 表示

*** バー

メニューバーもツールバーも消す。

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+end_src

*** カーソル

カーソルの点滅を止める。

#+begin_src emacs-lisp
  (blink-cursor-mode 0)
#+end_src

現在行を目立たせる。

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

カーソルの位置が何文字目・何行目かを表示する。

#+begin_src emacs-lisp
  (column-number-mode t)
  (line-number-mode t)
#+end_src

前回そのファイルを閉じた時のカーソル位置を復元する。

#+begin_src emacs-lisp
  (require 'saveplace)
  (save-place-mode 1)
#+end_src

括弧にカーソルがある時に中身を光らせる。

#+begin_src emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'expression)
#+end_src

*** 文字色と背景色

#+begin_src emacs-lisp
  (setq default-frame-alist
         (append
          '((background-color . "#274444")
            (foreground-color . "khaki")
            )
          default-frame-alist))
  (setq initial-frame-alist default-frame-alist)

#+end_src

*** diff

#+begin_src emacs-lisp
  (defun diff-mode-setup-faces ()
    ;; 追加された行は緑で表示
    (set-face-attribute 'diff-added nil
                        :foreground "white" :background "dark green")
    ;; 削除された行は赤で表示
    (set-face-attribute 'diff-removed nil
                        :foreground "white" :background "dark red")
    ;; 文字単位での変更箇所は色を反転して強調
    (set-face-attribute 'diff-refine-change nil
                        :foreground nil :background nil
                        :weight 'bold :inverse-video t))
  (add-hook 'diff-mode-hook 'diff-mode-setup-faces)

  ;; diffを表示したらすぐに文字単位での強調表示も行う
  (defun diff-mode-refine-automatically ()
    (diff-auto-refine-mode t))
  (add-hook 'diff-mode-hook 'diff-mode-refine-automatically)

  ;; ediffを1ウィンドウで実行
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  ;; diffのオプション
  (setq diff-switches '("-u" "-p" "-N"))
#+end_src

* emacs 全体にかかるキー入力

** キーバインド追加

下記のうち、 grep は下の方で拡張しているので注意。

#+begin_src emacs-lisp
  (define-key global-map (kbd "M-?") 'help-for-help)     ; ヘルプ
  (define-key global-map (kbd "C-z") 'undo)              ; undo
  (define-key global-map (kbd "C-c C-i") 'hippie-expand) ; 補完
  (define-key global-map (kbd "C-c ;") 'comment-dwim)    ; コメントアウト
  (define-key global-map (kbd "M-C-g") 'grep)            ; grep
  (define-key global-map (kbd "C-[ M-C-g") 'goto-line)   ; 指定行へ移動
  ;; ウィンドウ移動
  ;; 次のウィンドウへ移動
  (define-key global-map (kbd "C-M-n") 'next-multiframe-window)
  ;; 前のウィンドウへ移動
  (define-key global-map (kbd "C-M-p") 'previous-multiframe-window)
#+end_src

関数定義への移動用キーバインドを設定する。

- C-x F -> 関数定義へ移動
- C-x K -> キーにバインドされている関数定義へ移動
- C-x V -> 変数定義へ移動

#+begin_src emacs-lisp
  (find-function-setup-keys)
#+end_src

** 既存設定の変更

バックスペースを C-h に変更する。

#+begin_src emacs-lisp
  (keyboard-translate ?\C-h ?\C-?)
#+end_src

使わない割に誤爆する設定を無効化する。

#+begin_src emacs-lisp
  ;; suspend-frame だが使わない
  (define-key global-map (kbd "C-x C-z") nil)
#+end_src

** 文字関連のモードの設定

リージョン選択時の大文字小文字変換を有効にする。

#+begin_src emacs-lisp
  (put 'upcase-region 'disabled nil) ;; C-x C-u
  (put 'downcase-region 'disabled nil) ;; C-x C-l
#+end_src

C-j でインデントつき改行し、RETは改行のみにする。

#+begin_src emacs-lisp
  (electric-indent-mode -1)
#+end_src

すべてのインデントをスペースで入力する。

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

* ビルトインパッケージの拡張

独自コマンドの実装にも影響がありうるため、独自コマンドの実装よりも先に定義しておく。

** dired

#+begin_src emacs-lisp
    (require 'dired-x)
    (require 'wdired)

    ;; diredから"r"でファイル名をインライン編集する
    (define-key dired-mode-map "r" 'wdired-change-to-wdired-mode)
#+end_src

** grep

#+begin_src emacs-lisp
  (require 'grep)
  (setq grep-command-before-query "grep -nH -r -e ")
  (defun grep-default-command ()
    (if current-prefix-arg
        (let ((grep-command-before-target
               (concat grep-command-before-query
                       (shell-quote-argument (grep-tag-default)))))
          (cons (if buffer-file-name
                    (concat grep-command-before-target
                            " *."
                            (file-name-extension buffer-file-name))
                  (concat grep-command-before-target " ."))
                (+ (length grep-command-before-target) 1)))
      (car grep-command)))
  (setq grep-command (cons (concat grep-command-before-query " .")
                           (+ (length grep-command-before-query) 1)))
#+end_src

* 独自コマンド実装

** バージョン管理システム

dired からバージョン管理システムの *-status を起動するコマンド。
wdired と magit に依存。（本来は svn-status にも依存しているがほとんど使わないので入れてない）

#+begin_src emacs-lisp
  (defun find-path-in-parents (directory base-names)
    (or (cl-find-if 'file-exists-p
                 (mapcar (lambda (base-name)
                           (concat directory base-name))
                         base-names))
        (if (string= directory "/")
            nil
          (let ((parent-directory (substring directory 0 -1)))
            (find-path-in-parents parent-directory base-names)))))

  (setq this-file-path (file-name-directory (or load-file-name (buffer-file-name))))

  (defun dired-vc-status (&rest args)
    (interactive)
    (let ((path (find-path-in-parents (dired-current-directory)
                                      '(".svn" ".git"))))
      (cond ((null path)
             (message "not version controlled."))
            ((string-match-p "\\.svn$" path)
             (svn-status (file-name-directory path)))
            ((string-match-p "\\.git$" path)
             (magit-status (file-name-directory path))))))

  (define-key dired-mode-map "V" 'dired-vc-status)
#+end_src

** git grep

emacs の grep の方式で git grep を実行して結果からジャンプできるコマンド。

#+begin_src emacs-lisp
  (defun self-git-grep--chomp (str)
    (replace-regexp-in-string "[\n\r]+$" "" str))
  (defun self-git-grep--git-project-p ()
    (string=
     (self-git-grep--chomp
      (shell-command-to-string "git rev-parse --is-inside-work-tree"))
     "true"))

  (defun self-git-grep--git-root-directory ()
    (cond ((self-git-grep--git-project-p)
           (self-git-grep--chomp
            (shell-command-to-string "git rev-parse --show-toplevel")))
          (t
           "")))
  (defun git-grep (grep-dir command-args)
    (interactive
     (let ((root (concat (self-git-grep--git-root-directory) "/")))
       (list
        (read-file-name
         "Directory for git grep: " root root t)
        (read-shell-command
              "Run git-grep (like this): "
              (format "PAGER='' git --no-pager grep -I -n -i -e %s"
                      "")
              'git-grep-history))))

    ;; emacs 27.2 から let で grep-use-null-device の値を設定できなかったので
    ;; grep の実行前後で設定する
    (setq grep-use-null-device nil)
    (let ((command
           (format (concat
                    "cd %s && "
                    "%s")
                   grep-dir
                   command-args)))
      (grep command))
      (setq grep-use-null-device t))
#+end_src

** 行の折り返し制御

実行したバッファの行の折り返しを制御する。

#+begin_src emacs-lisp
  (defun toggle-truncate-lines ()
    (interactive)
    (if truncate-lines
        (setq truncate-lines nil)
      (setq truncate-lines t))
    (recenter))

  (global-set-key "\C-c\C-l" 'toggle-truncate-lines)
#+end_src

** re-builder

正規表現での置換に re-builder を使えるようにする。

*** 実行時の設定

#+begin_src emacs-lisp
  (require 're-builder)
  ;; 文字列リテラルではなく正規表現そのもの
  (setq reb-re-syntax 'string)
  (defvar reb-target-point nil)
  (defun re-builder-with-point ()
    "C-M-%仕様。現在位置から置換を開始するre-builder"
    (interactive)
    (setq reb-target-point (point))
    (re-builder))
  (defun re-builder-without-point ()
    "元のM-x re-builder"
    (interactive)
    (setq reb-target-point nil)
    (re-builder))
  (defadvice reb-update-overlays (after with-point activate)
    (when reb-target-point
      (with-selected-window reb-target-window
        (goto-char reb-target-point))))
  (global-set-key (kbd "C-M-%") 're-builder-with-point)
#+end_src

*** 置換開始コマンド

re-builder バッファ内で置換を開始する関数をキーに割り当て。

#+begin_src emacs-lisp
  (define-key reb-mode-map (kbd "<return>") 'reb-query-replace-this-regxp)
#+end_src

その関数の実装。

#+begin_src emacs-lisp
  (defun reb-query-replace-this-regxp (replace)
    "re-builder バッファ内の正規表現で、ターゲットバッファ内の置き換えをする。
  re-builder バッファ内で実行することを想定している。
  この関数の引数を置換先の文字列として使う。 \1 や \2 といった文字列で正規表現ん内の文字列を参照できる。"
    (interactive "sReplace with: ")
    (if (eq major-mode 'reb-mode)
        (let (o (reg (reb-read-regexp)))
          (select-window reb-target-window)
          (save-excursion
            (setq o (cl-find-if (lambda (ov) (eq (point) (overlay-end ov))) reb-overlays))
            (if o (goto-char (overlay-start o)))
            (query-replace-regexp reg replace)
            (reb-quit)))
      (error "Not in a re-builder buffer!")))
#+end_src

*** 正規表現での検索

入力されている正規表現でターゲットバッファ内を検索する C-c C-s / C-c C-r を C-s / C-r に割り当て。

#+begin_src emacs-lisp
  (define-key reb-mode-map (kbd "C-s") 'reb-next-match)
  (define-key reb-mode-map (kbd "C-r") 'reb-prev-match)
#+end_src

*** 終了時の正規表現コピー

終了する際に正規表現をコピーするように関数をキーに割り当て。
また C-c C-q を C-g にしている。

#+begin_src emacs-lisp
  (define-key reb-mode-map (kbd "C-g") 'reb-copy-and-quit)
  (define-key reb-mode-map (kbd "C-c C-q") 'reb-copy-and-quit)
#+end_src

その関数の実装。

#+begin_src emacs-lisp
  (defun reb-copy-and-quit ()
    (interactive)
    (reb-copy)
    (reb-quit))
#+end_src

*** クリア時の正規表現コピー

クリアするときは正規表現だけをクリアするように関数をキーに割り当て。
また C-c C-w を C-k にしている。

#+begin_src emacs-lisp
  (define-key reb-mode-map (kbd "C-k") 'reb-copy-and-erase)
  (define-key reb-mode-map (kbd "C-c C-k") 'reb-copy-and-erase)
#+end_src

その関数の実装。

#+begin_src emacs-lisp
  (defun reb-copy-and-erase ()
    (interactive)
    (reb-copy)
    (with-current-buffer reb-target-buffer (setq reb-regexp nil))
    (erase-buffer)
    (reb-insert-regexp)
    (forward-char -1))
#+end_src
